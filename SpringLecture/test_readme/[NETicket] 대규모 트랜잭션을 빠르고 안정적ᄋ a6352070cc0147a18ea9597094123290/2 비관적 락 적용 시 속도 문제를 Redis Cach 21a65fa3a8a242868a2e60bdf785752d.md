# 2. 비관적 락 적용 시 속도 문제를 Redis Cache로 해결

## 🆘 문제

<aside>
⚠️ 문제 : 비관적 락을 적용하고 예매 로직에 10K 요청 테스트 진행 시 평균 응답속도 49368ms( 77tps) 수준으로 지나치게 느려 속도 개선이 필요했습니다.

</aside>

| 라벨 | 표본 수 | 평균 응답 속도 | 최소값 | 최대값 | 표준편차 | 오류 % | 처리량(tps) | 수신 KB/초 | 전송 KB/초 | 평균 바이트 수 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 비관적락 적용 | 10000 | 49368ms | 167 | 113230 | 30585.155171191138 | 0.1466 | 77.66145817153863 | 52.308033313367865 | 26.989465101853 | 689.7041 |

---

## 👁‍🗨 분석

```java
@Transactional
  public Long makeReservations(ReservationRequestDto dto, User user) {
    TicketInfo ticketInfo = ticketInfoRepository.**findByIdWithLock**(dto.getTicketInfoId()).orElseThrow(
        () -> new IllegalArgumentException("공연회차 정보가 없습니다.")
    );

// ------------------------------------------------------------
public interface TicketInfoRepository extends JpaRepository<TicketInfo, Long> {

  @Lock(LockModeType.PESSIMISTIC_WRITE)
  @Query("SELECT t FROM TicketInfo t WHERE t.id = :id")
  Optional<TicketInfo> findByIdWithLock(@Param("id") Long id);
}
```

<aside>
💡 비관적 쓰기 락이 데이터 무결성을 지키기는 좋지만 DB에서 트랜잭션이 끝날 때까지 다른 트랜잭션의 접근을 막기 때문에 속도가 저하된다고 판단했습니다.

</aside>

---

## 🌟시도

### 1. Redis를 도입해 비관적 락을 대신해 Redisson 락을 적용

- 예매 로직 구현 코드
    
    ```java
    @Configuration
    public class RedisConfig {
    
      @Value("${spring.redis.host}")
      private String host;
    
      @Value("${spring.redis.port}")
      private int port;
    
      @Bean
      public RedisConnectionFactory redisConnectionFactory() {
        return new RedissonConnectionFactory();
      }
    
      @Bean(destroyMethod = "shutdown")
      public RedissonClient redissonClient() {
        Config config = new Config();
        config.useSingleServer()
            .setAddress("redis://" + host + ":" + port);
        return Redisson.create(config);
      }
    }
    
    // -----------------------------------------------
    @Service
    @RequiredArgsConstructor
    public class ReservationLockFacade {
    
      private final ReservationService reservationService;
      private final RedissonClient redissonClient;
    
      public Long makeReservation(ReservationRequestDto dto, User user){
        Long ticketInfoId = dto.getTicketInfoId();
        RLock lock = redissonClient.getLock(String.format("reservation:ticketinfo:%d",ticketInfoId));
        try{
          boolean available = lock.tryLock(60,1, TimeUnit.SECONDS);
          if (!available){
            System.out.println("redisson getLock timeout");
            throw new IllegalArgumentException("redisson getLock timeout");
          }
          return reservationService.makeReservations(dto, user, ticketInfoId);
        } catch (Exception e){
          throw new RuntimeException(e);
        } finally {
          lock.unlock();
        }
      }
    }
    ```
    

- 낙관적락, 비관적락이 아닌 다른 Lock을 걸어 속도를 개선해 보고자 Redis에서 지원하는 분산락(Distribution Lock)의 일종인 Redisson Lock을 적용해보고자 했습니다.
- Facade를 만들어 여기서 Lock을 건 채로 예매 서비스 로직을 실행하고 로직이 끝나면 unlock을 호출해 락을 반납하게 했습니다.
- 하지만 평균 응답속도는 개선되지 않고 오히려 증가해 해당 시도는 실패했습니다.

[230407 네 번재 테스트 - Redisson 락](https://www.notion.so/230407-Redisson-4c0d95108a5b4a288f2de68d356200f9)

| 라벨 | 표본 수 | 평균 응답 속도 | 최소값 | 최대값 | 표준편차 | 오류 % | 처리량(tps) | 수신 KB/초 | 전송 KB/초 | 평균 바이트 수 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Redisson 락 적용 | 10000 | 60896ms | 52 | 138621 | 38921.097098016224 | 0.1677 | 69.15772803031875 | 48.73958419780493 | 23.620193916108217 | 721.674 |

---

### 2. Tomcat 최대 커넥션 수와 쓰레드 풀, DB 커넥션 풀 조정

```yaml
server:
  tomcat:
    accept-count: 500
    threads:
      min-spare: 500
      max: 1000
    max-connections: 25000
```

- 스프링부트 내장 웹 서버인 Tomcat의 설정을 application.yaml 에서 조정해 최대 커넥션 수와 쓰레드 풀을 설정하고, RDS MySQL의 max_connections 수치를 조정했습니다.
- 미리 쓰레드풀을 만들어 쓰레드 생성에 비용을 아끼고 최대 커넥션의 수를 늘려 속도 개선을 해보고자 했습니다.
- jmeter 테스트 시 20K 이상 요청에서 HttpHostConnectException은 사라졌지만 속도에서 큰 개선이 있다고 볼 수는 없었습니다.

[230410 다섯 번째 테스트 ](https://www.notion.so/230410-873805553449465fbd8319c20f88e478)

| 라벨 | 표본 수 | 평균 응답 속도 | 최소값 | 최대값 | 표준편차 | 오류 % | 처리량(tps) | 수신 KB/초 | 전송 KB/초 | 평균 바이트 수 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Tomcat 튜닝 | 10000 | 40954ms | 106 | 86708 | 24124.13656688543 | 0.1462 | 103.48752975266481 | 69.7306353002432 | 35.98158326218566 | 689.9785 |

---

### 3. Redis에 TicketInfo의 남은 좌석 수를 캐시로 저장해 예매 로직에 활용

- 남은 좌석 수 캐시 전략(최종본)

![캐시전략 Flow Chart.png](2%20%E1%84%87%E1%85%B5%E1%84%80%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%A8%20%E1%84%85%E1%85%A1%E1%86%A8%20%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%89%E1%85%B5%20%E1%84%89%E1%85%A9%E1%86%A8%E1%84%83%E1%85%A9%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%E1%84%85%E1%85%B3%E1%86%AF%20Redis%20Cach%2021a65fa3a8a242868a2e60bdf785752d/%25EC%25BA%2590%25EC%258B%259C%25EC%25A0%2584%25EB%259E%25B5_Flow_Chart.png)

- RedisConfig
    
    ```java
    @Configuration
    @EnableCaching
    public class RedisConfig {
    
      @Value("${spring.redis.host}")
      private String host;
    
      @Value("${spring.redis.port}")
      private int port;
    
      @Bean
      public RedisConnectionFactory redisConnectionFactory() {
        return new LettuceConnectionFactory(host, port);
      }
    
      //  LeftSeats에 사용하는 redisTemplate
      @Bean
      public RedisTemplate<String, Integer> redisTemplate() {
        RedisTemplate<String, Integer> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(redisConnectionFactory());
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer<>(Integer.class));
        return redisTemplate;
      }
    ```
    
- RedisRepository
    
    ```java
    @Component
    @RequiredArgsConstructor
    public class RedisRepository {
      private final RedisTemplate<String, Integer> redisTemplate;
      private final TicketInfoRepository ticketInfoRepository;
      private final ReservationRepository reservationRepository;
      private static final String DECREMENT_LEFT_SEAT_SCRIPT =
          "local leftSeats = tonumber(redis.call('get', KEYS[1])) " +
          "if leftSeats - ARGV[1] >= 0 then " +
          "  redis.call('decrby', KEYS[1], ARGV[1]) " +
          "  return true " +
          "else " +
          "  return false " +
          "end";
    
      private final RedisScript<Boolean> decrementLeftSeatRedisScript = new DefaultRedisScript<>(DECREMENT_LEFT_SEAT_SCRIPT, Boolean.class);
    
      //  키를 ls1 ls2 이런 패턴으로 "ls+ticketInfoId"로 저장. ls는 소문자. 키가 이미 존재하면 예외처리
      public void saveTicketInfoToRedis(TicketInfo ticketInfo) {
        String key = "ls" + ticketInfo.getId();
        if (redisTemplate.hasKey(key)) {
          throw new CustomException(ExceptionType.EXISTED_CACHE_EXCEPTION);
        }
        redisTemplate.opsForValue().set(key, ticketInfo.getLeftSeats());
      }
    
    //  매분 캐시 변경분을 db에 저장
      @Scheduled(cron = "0 * * * * *")
      public void saveTicketInfoFromRedis(){
        Set<String> keys = redisTemplate.keys("ls*");
        if (keys.isEmpty() || keys == null) return;
        for (String key : keys) {
          Integer leftSeatsInRedis = redisTemplate.opsForValue().get(key);
          Long ticketInfoId = Long.parseLong(key.substring(2));
          TicketInfo ticketInfo = ticketInfoRepository.findById(ticketInfoId).orElseThrow(
              () -> new CustomException(ExceptionType.NOT_FOUND_TICKET_INFO_EXCEPTION));
          ticketInfo.setLeftSeats(leftSeatsInRedis);
          ticketInfoRepository.save(ticketInfo);
        }
    
      }
    
    //  key로 redis에 캐시가 있는지 조회하고 Boolean 반환
      public Boolean hasLeftSeatsInRedis(Long ticketInfoId){
        String key = "ls" + ticketInfoId;
        return redisTemplate.hasKey(key);
      }
    
    //  값 변경. count만큼 남은좌석수 차감
      public Boolean decrementLeftSeatInRedis(Long ticketInfoId, int count){
        String key = "ls" + ticketInfoId;
    //    Lua Script 실행
        return redisTemplate.execute(decrementLeftSeatRedisScript, Collections.singletonList(key), count);
      }
    
      //  값 변경. count만큼 남은좌석수 추가. 예매취소에 사용
      public void incrementLeftSeatInRedis(Long ticketInfoId, int count){
        String key = "ls" + ticketInfoId;
        redisTemplate.opsForValue().increment(key, count);
      }
    
    //  키 삭제. 삭제전 leftSeats 반영. 캐시가 없으면 예외처리
      public void deleteLeftSeatsInRedis(Long ticketInfoId){
        String key = "ls" + ticketInfoId;
        if (!redisTemplate.hasKey(key)) {
          throw new CustomException(ExceptionType.NOT_FOUND_CACHE_EXCEPTION);
        }
        saveTicketInfoFromRedis();
        redisTemplate.delete(key);
      }
    
    //  현재 Redis에 등록된 key 목록 반환
      public Set<String> findAllLeftSeatsKeysInRedis() {
        return redisTemplate.keys("ls*");
      }
    
    // Redis와 DB에 들어있는 LeftSeat의 정합성을 맞추기 위해 Reservation에서 ticketInfoId로 조회한 모든 count를 더해
    //  accurateReservedSeats를 구하고 totalSeats에서 뺀 다음 accurateReservedSeats을 구해서 DB와 Redis에 맞춰줌.
      public void refreshLeftSeats(Long ticketInfoId) {
        TicketInfo ticketInfo = ticketInfoRepository.findById(ticketInfoId).orElseThrow(
            () -> new CustomException(ExceptionType.NOT_FOUND_TICKET_INFO_EXCEPTION)
        );
        Integer accurateReservedSeats = reservationRepository.sumCountByTicketInfoId(ticketInfoId);
        if (accurateReservedSeats == null) {
          throw new CustomException(ExceptionType.NOT_FOUND_RESERVATION_EXCEPTION);
        }
        int accurateLeftSeats = ticketInfo.getTotalSeats() - accurateReservedSeats;
        String key = "ls" + ticketInfoId;
        ticketInfo.setLeftSeats(accurateLeftSeats);
    //    덮어 쓰기
        redisTemplate.opsForValue().set(key, accurateLeftSeats);
      }
    }
    ```
    
- 예매 서비스 로직
    
    ```java
    // 2. 예매하기
      @Transactional(isolation = Isolation.READ_COMMITTED)
      public Long makeReservation(ReservationRequestDto dto, User user) {
        //    먼저 redis 캐시를 조회
        Boolean hasLeftSeats = redisRepository.hasLeftSeatsInRedis(dto.getTicketInfoId());
        if (hasLeftSeats) {
          //    캐시가 있으면 redis에서 남은 좌석 수 차감
          decrementLeftSeatInRedis(dto);
        } else {
          //    캐시가 없으면 DB를 통해 남은 좌석 수 차감
          decrementLeftSeatInDB(dto);
        }
    
        Reservation reservation = new Reservation(dto, user);
        reservationRepository.saveAndFlush(reservation);
        return reservation.getId();
      }
    
      //  2-1. redis로 좌석 수 변경
      private void decrementLeftSeatInRedis(ReservationRequestDto dto) {
        Boolean success = redisRepository.decrementLeftSeatInRedis(dto.getTicketInfoId(), dto.getCount());
        if (!success) {
          throw new CustomException(ExceptionType.OUT_OF_TICKET_EXCEPTION);
        }
      }
    
      // 2-2. 캐시 없으면 DB로 좌석수 변경
      private void decrementLeftSeatInDB(ReservationRequestDto dto) {
        TicketInfo ticketInfo = ticketInfoRepository.findByIdWithLock(dto.getTicketInfoId()).orElseThrow(
            () -> new CustomException(ExceptionType.NOT_FOUND_TICKET_INFO_EXCEPTION)
        );
        if (!ticketInfo.isAvailable()) {
          throw new CustomException(ExceptionType.RESERVATION_UNAVAILABLE_EXCEPTION);
        }
        if (ticketInfo.getLeftSeats() - dto.getCount() < 0) {
          throw new CustomException(ExceptionType.OUT_OF_TICKET_EXCEPTION);
        }
        ticketInfo.minusSeats(dto.getCount());
        ticketInfoRepository.save(ticketInfo);
      }
    ```
    

- **인메모리 저장소, 싱글 스레드, 단순연산의 경우 원자성 보장**이라는 특성을 가진 Redis를 도입해서 속도 개선과 동시성제어 두 마리 토끼를 한 번에 잡아보고자 했습니다.
- Key는 “ls+ticketInfoId”, Value는 TicketInfo Entity에 있는 LeftSeats(남은 좌석 수) 컬럼의 데이터로 <String, Integer> 구조의 ‘Redis 기본 String 자료구조’로 Redis에 저장했습니다.
- 예매 트랜잭션이 시작되면 먼저 해당 TicketInfo의 key가 Redis에 있는지 확인합니다. 해당 키가 있으면 Redis로 남은 좌석 수를 차감해 예매를 진행하고, 없거나 Redis 연결에 문제가 생기면 기존 DB의 비관적 락 로직으로 남은 좌석 수를 차감해 예매를 진행합니다. (이 로직은 트러블 슈팅 5번에서 최종적으로 변경되었습니다.)
- Redis로 아래의 Lua Script를 보내서 남은 좌석 수가 예매하려는 자리 수(count) 이상일 경우 value를 차감한 뒤 true를 반환하고, 아니면 false를 반환합니다. 이 스크립트는 단순 연산으로 원자성이 보장됩니다.

```java
  private static final String DECREMENT_LEFT_SEAT_SCRIPT =
      "local leftSeats = tonumber(redis.call('get', KEYS[1])) " +
      "if leftSeats - ARGV[1] >= 0 then " +
      "  redis.call('decrby', KEYS[1], ARGV[1]) " +
      "  return true " +
      "else " +
      "  return false " +
      "end";

public Boolean decrementLeftSeatInRedis(Long ticketInfoId, int count) {
    String key = "ls" + ticketInfoId;
    return redisTemplate.execute(decrementLeftSeatRedisScript, Collections.singletonList(key),
        count);
  }
```

- 캐시 자동 적용 로직
    
    ```java
    @Slf4j
    @Service
    @RequiredArgsConstructor
    public class TicketInfoService {
    
      private final TicketInfoRepository ticketInfoRepository;
      private final RedisRepository redisRepository;
      private final ReservationRepository reservationRepository;
      private final RedisTemplate<String, DetailEventResponseDto> redisTemplate;
    
      /*
       * 매일 자정에 돌아가는 스케쥴러 오늘이 공연일인 모든 공연을 예매 불가능으로 돌린다.
       * repository에서 오늘이 공연 당일인 공연의 ticketInfo를 다 불러온다.
       * 해당 공연의 dto 캐시를 삭제한다. 해당 공연의 leftSeats 캐시도 삭제하고 DB에 정합성을 맞춘다.
       * ticketInfo에 변화가 생긴 것을 repository에 반영한다.
       */
      @Scheduled(cron = "0 0 0 * * ?")
      public void closeTicket() {
        List<TicketInfo> ticketInfos = ticketInfoRepository.findTicketInfoByEventDate();
        for (TicketInfo ticketInfo : ticketInfos) {
          ticketInfo.setAvailable(false);
          deleteDtoCache(ticketInfo);
          redisRepository.deleteLeftSeatsInRedis(ticketInfo);
          log.info("{}번 공연이 예매불가능으로 수정되었습니다.", ticketInfo.getEvent().getId());
        }
        ticketInfoRepository.saveAll(ticketInfos);
    
      }
    
      // dto 캐시를 삭제하는 private 메서드
      private void deleteDtoCache(TicketInfo ticketInfo) {
        String cacheKey = "DetailEventResponseDto::" + ticketInfo.getEvent().getId();
        Boolean eventCache = redisTemplate.hasKey(cacheKey);
        if (eventCache != null && eventCache) {
          redisTemplate.delete(cacheKey);
        }
      }
    
      /*
       * 매일 18시 티켓정보의 openDate가 오늘인 공연의 isAvailable을 true로 바꾼다.
       * 해당 ticketInfo의 leftSeats를 redis의 캐시로 저장한다.
       */
      @Scheduled(cron = "0 0 18 * * ?")
      public void openTicket() {
        List<TicketInfo> ticketInfos = ticketInfoRepository.findTicketInfoByOpenDate();
        for (TicketInfo ticketInfo : ticketInfos) {
          deleteDtoCache(ticketInfo);
          ticketInfo.setAvailable(true);
          redisRepository.saveTicketInfoToRedis(ticketInfo);
          log.info("{}번 공연이 예매가능으로 수정되었습니다.", ticketInfo.getEvent().getId());
        }
        ticketInfoRepository.saveAll(ticketInfos);
      }
    ```
    
- Write Back 캐시 전략
    
    ![Untitled](2%20%E1%84%87%E1%85%B5%E1%84%80%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%A8%20%E1%84%85%E1%85%A1%E1%86%A8%20%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%89%E1%85%B5%20%E1%84%89%E1%85%A9%E1%86%A8%E1%84%83%E1%85%A9%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%E1%84%85%E1%85%B3%E1%86%AF%20Redis%20Cach%2021a65fa3a8a242868a2e60bdf785752d/Untitled.png)
    
    그림 출처([https://inpa.tistory.com/entry/REDIS-📚-캐시Cache-설계-전략-지침-총정리](https://inpa.tistory.com/entry/REDIS-%F0%9F%93%9A-%EC%BA%90%EC%8B%9CCache-%EC%84%A4%EA%B3%84-%EC%A0%84%EB%9E%B5-%EC%A7%80%EC%B9%A8-%EC%B4%9D%EC%A0%95%EB%A6%AC))
    
- Write Back 캐시 쓰기 전략으로 캐시에 있는 남은 좌석 수 값이 DB의 TicketInfo 테이블의 LeftSeats 컬럼에 매 분마다 저장됩니다.
- 해당 캐시는 예매가 오픈될 때 생성되어 공연일이 되어 예매가 닫히면 expire 됩니다. 캐시가 사라지면 Reservation 테이블에서 해당 TicketInfo의 예매 count를 다 더해서 정확한 남은 좌석 수를 DB 안의 TicketInfo에 넣습니다.

---

## 💡 해결

<aside>
🛠 Redis의 ‘원자적 연산’으로 락을 적용하지 않아도 트랜잭션의 충돌 없이 남은 좌석 수를 차감하는 로직을 구현해 10K 요청 테스트 시 평균 응답속도 11492ms(333tps).  비관적 락 대비 약 76% 의 속도 개선을 성공했습니다.

</aside>

[230418 여섯 번째 테스트(캐시 적용)](https://www.notion.so/230418-16e58b3405484ce6ac0f07fd264fe9a8)

| 라벨 | 표본 수 | 평균 응답 속도 | 최소값 | 최대값 | 표준편차 | 오류 % | 처리량(tps) | 수신 KB/초 | 전송 KB/초 | 평균 바이트 수 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Redis 캐시 적용 | 10000 | 11492ms | 127 | 20504 | 5469.811458239943 | 0.0 | 333.8452293516726 | 117.02644575849637 | 135.95064515590573 | 358.954 |