# 1. 트랜잭션 충돌 문제를 비관적 락으로 해결

## 🆘 문제

<aside>
⚠️ 예매 서비스 로직을 만들고 나서 바로 테스트를 했더니 
트랜잭션이 50개 정도만 동시에 들어와도 LockAcquisitionException이 발생하고, 
TicketInfo의 남은 좌석 수가 실제 수치(총 좌석 수 - Reservation에서 count 합산)보다 더 많아 데이터 무결성이 깨지는 문제 발생했습니다.

</aside>

```json
{
"statusCode":400,
"msg":"could not execute statement; SQL [n/a]; nested exception is org.hibernate.exception.LockAcquisitionException"
}
```

---

## 👁‍🗨 분석

- 예매하기 서비스 코드
    
    ```java
    // 예매하기
      @Transactional
      public Long makeReservations(ReservationRequestDto dto, User user) {
        TicketInfo ticketInfo = ticketInfoRepository.findById(dto.getTicketInfoId())
    		.orElseThrow(
            () -> new IllegalArgumentException("공연회차 정보가 없습니다.")
        );
        if (!ticketInfo.isAvailable()) {
          throw new IllegalArgumentException("현재 예매가 불가능한 공연입니다.");
        }
    
        if (ticketInfo.getTotalSeats() >= ticketInfo.getReservedSeats() + dto.getCount()) {
          ticketInfo.reserveSeats(dto.getCount());
    
          // 만약 ReservedSeats와 TotalSeats가 같아지면 isAvailable을 false로 변경
          if (ticketInfo.getTotalSeats() == ticketInfo.getReservedSeats()) {
            ticketInfo.setAvailable(false);
          }
          ticketInfoRepository.save(ticketInfo);
          Reservation reservation = new Reservation(dto, user, ticketInfo);
          reservationRepository.saveAndFlush(reservation);
          return reservation.getId();
        }
        throw new IllegalArgumentException("남은 자리가 없습니다");
      }
    ```
    

<aside>
💡 동시에 여러 트랜잭션이 TicketInfo Entity를 불러와서 
남은 좌석 수 칼럼을 읽고 수정하는 과정에서 트랜잭션끼리 충돌이 발생해 
데이터 무결성이 지켜지지 않는다고 판단했습니다.

</aside>

---

## 🌟 시도

### 1. **트랜잭션 격리 수준(isolation level)을 READ COMMITTED, REPEATABLE READ, SERIALIZABLE로 변경**

```java
@Transactional(isolation = Isolation.READ_COMMITTED)
@Transactional(isolation = Isolation.REPEATABLE_READ)
@Transactional(isolation = Isolation.SERIALIZABLE)
```

- READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE으로 구분되는 
트랜잭션 격리 수준을 조정해 데이터의 일관성을 지켜보려 했습니다.
- 하지만 테스트 결과 LockAcquisitionException이 여전히 발생하고 남은 좌석 수가 불일치했습니다.

---

### 2. **낙관적 락(Optimistic Lock) 적용**

```java
@Entity
@Getter
@NoArgsConstructor
public class TicketInfo {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;
	
	// 낙관적 락 적용
  @Version
  private Long version;
```

- JPA 락 중에 낙관적 락(Optimistic Lock)을 적용해서 이 문제를 해결해보고자 했습니다.
공유자원인 TicketInfo에 @Version 어노테이션을 만들어 낙관적 락을 적용했습니다.
하지만 테스트 결과 여전히 LockAcquisitionException 이 발생하고 남은 좌석 수가 불일치했습니다.

---

### 3. **비관적 락(Pessimistic Lock) 적용**

```java
@Transactional
  public Long makeReservations(ReservationRequestDto dto, User user) {
    TicketInfo ticketInfo = ticketInfoRepository.**findByIdWithLock**(dto.getTicketInfoId()).orElseThrow(
        () -> new IllegalArgumentException("공연회차 정보가 없습니다.")
    );

// ------------------------------------------------------------
public interface TicketInfoRepository extends JpaRepository<TicketInfo, Long> {

  @Lock(LockModeType.PESSIMISTIC_WRITE)
  @Query("SELECT t FROM TicketInfo t WHERE t.id = :id")
  Optional<TicketInfo> findByIdWithLock(@Param("id") Long id);
}
```

- JPA 락 중에 비관적 락(Pessimistic Lock) 중 비관적 쓰기 락(PESSIMISTIC_WRITE LOCK)을 적용해 문제를 해결해보고자 했습니다.
- 공유자원인 TicketInfo를 TicketInfoRepository에서 불러올 때, @Lock 어노테이션으로 비관적 쓰기 락을 적용해서 한 트랜잭션이 이 TicketInfo를 읽고 수정하는 동안 다른 트랜잭션이 접근하지 못하게 했습니다.

---

## 💡 해결

<aside>
🛠 비관적 쓰기 락을 적용했더니  LockAcquisitionException 이 사라지고 
Reservation 테이블에 해당 공연의 count를 모두 더한 값과 
TicketInfo의 총 좌석 수에서 남은 좌석 수를 뺀 값의 데이터 무결성이 지켜지게 되었습니다.

</aside>

[230405 두 번째 테스트 - 비관적락 적용](https://www.notion.so/230405-2f58f50ede7d4d289f5a1a0617082b6f)

### 📊 예매하기 서비스 로직에 10K 요청 결과

| 라벨 | 표본 수 | 평균 응답 속도 | 최소값 | 최대값 | 표준편차 | 오류 % | 처리량(tps) | 수신 KB/초 | 전송 KB/초 | 평균 바이트 수 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Neticket | 10000 | 49368ms | 167 | 113230 | 30585.155171191138 | 0.1466 | 77.66145817153863 | 52.308033313367865 | 26.989465101853 | 689.7041 |

(오류 %는 jmeter를 실행하는 컴퓨터 내부 오류로 인해 발생)